/// Generated by the Protocol Buffers 3.7.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "interface.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct InterfaceRoot {
    public static let `default` = InterfaceRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class KpAlive : GeneratedMessage {
    public typealias BuilderType = KpAlive.Builder

    public static func == (lhs: KpAlive, rhs: KpAlive) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasPacketType == rhs.hasPacketType) && (!lhs.hasPacketType || lhs.packetType == rhs.packetType)
        fieldCheck = fieldCheck && (lhs.hasSensorId == rhs.hasSensorId) && (!lhs.hasSensorId || lhs.sensorId == rhs.sensorId)
        fieldCheck = fieldCheck && (lhs.hasAliveFlag == rhs.hasAliveFlag) && (!lhs.hasAliveFlag || lhs.aliveFlag == rhs.aliveFlag)
        fieldCheck = fieldCheck && (lhs.hasCountryCode == rhs.hasCountryCode) && (!lhs.hasCountryCode || lhs.countryCode == rhs.countryCode)
        fieldCheck = fieldCheck && (lhs.hasCityCode == rhs.hasCityCode) && (!lhs.hasCityCode || lhs.cityCode == rhs.cityCode)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    ///keep alive packet : 0
    public fileprivate(set) var packetType:String! = nil
    public fileprivate(set) var hasPacketType:Bool = false

    ///sensor ID
    public fileprivate(set) var sensorId:String! = nil
    public fileprivate(set) var hasSensorId:Bool = false

    public fileprivate(set) var aliveFlag:UInt32! = nil
    public fileprivate(set) var hasAliveFlag:Bool = false

    public fileprivate(set) var countryCode:String! = nil
    public fileprivate(set) var hasCountryCode:Bool = false

    public fileprivate(set) var cityCode:String! = nil
    public fileprivate(set) var hasCityCode:Bool = false

    public fileprivate(set) var version:String! = nil
    public fileprivate(set) var hasVersion:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasPacketType {
            try codedOutputStream.writeString(fieldNumber: 1, value:packetType)
        }
        if hasSensorId {
            try codedOutputStream.writeString(fieldNumber: 2, value:sensorId)
        }
        if hasAliveFlag {
            try codedOutputStream.writeUInt32(fieldNumber: 3, value:aliveFlag)
        }
        if hasCountryCode {
            try codedOutputStream.writeString(fieldNumber: 4, value:countryCode)
        }
        if hasCityCode {
            try codedOutputStream.writeString(fieldNumber: 5, value:cityCode)
        }
        if hasVersion {
            try codedOutputStream.writeString(fieldNumber: 6, value:version)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPacketType {
            serialize_size += packetType.computeStringSize(fieldNumber: 1)
        }
        if hasSensorId {
            serialize_size += sensorId.computeStringSize(fieldNumber: 2)
        }
        if hasAliveFlag {
            serialize_size += aliveFlag.computeUInt32Size(fieldNumber: 3)
        }
        if hasCountryCode {
            serialize_size += countryCode.computeStringSize(fieldNumber: 4)
        }
        if hasCityCode {
            serialize_size += cityCode.computeStringSize(fieldNumber: 5)
        }
        if hasVersion {
            serialize_size += version.computeStringSize(fieldNumber: 6)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> KpAlive.Builder {
        return KpAlive.classBuilder() as! KpAlive.Builder
    }
    public func getBuilder() -> KpAlive.Builder {
        return classBuilder() as! KpAlive.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return KpAlive.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return KpAlive.Builder()
    }
    public func toBuilder() throws -> KpAlive.Builder {
        return try KpAlive.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:KpAlive) throws -> KpAlive.Builder {
        return try KpAlive.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasPacketType {
            jsonMap["packetType"] = packetType
        }
        if hasSensorId {
            jsonMap["sensorID"] = sensorId
        }
        if hasAliveFlag {
            jsonMap["aliveFlag"] = UInt(aliveFlag)
        }
        if hasCountryCode {
            jsonMap["countryCode"] = countryCode
        }
        if hasCityCode {
            jsonMap["cityCode"] = cityCode
        }
        if hasVersion {
            jsonMap["version"] = version
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> KpAlive {
        return try KpAlive.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> KpAlive {
        return try KpAlive.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasPacketType {
            output += "\(indent) packetType: \(String(describing: packetType)) \n"
        }
        if hasSensorId {
            output += "\(indent) sensorId: \(String(describing: sensorId)) \n"
        }
        if hasAliveFlag {
            output += "\(indent) aliveFlag: \(String(describing: aliveFlag)) \n"
        }
        if hasCountryCode {
            output += "\(indent) countryCode: \(String(describing: countryCode)) \n"
        }
        if hasCityCode {
            output += "\(indent) cityCode: \(String(describing: cityCode)) \n"
        }
        if hasVersion {
            output += "\(indent) version: \(String(describing: version)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasPacketType {
                hashCode = (hashCode &* 31) &+ packetType.hashValue
            }
            if hasSensorId {
                hashCode = (hashCode &* 31) &+ sensorId.hashValue
            }
            if hasAliveFlag {
                hashCode = (hashCode &* 31) &+ aliveFlag.hashValue
            }
            if hasCountryCode {
                hashCode = (hashCode &* 31) &+ countryCode.hashValue
            }
            if hasCityCode {
                hashCode = (hashCode &* 31) &+ cityCode.hashValue
            }
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "KpAlive"
    }
    override public func className() -> String {
        return "KpAlive"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:KpAlive = KpAlive()
        public func getMessage() -> KpAlive {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        ///keep alive packet : 0
        public var packetType:String {
            get {
                return builderResult.packetType
            }
            set (value) {
                builderResult.hasPacketType = true
                builderResult.packetType = value
            }
        }
        public var hasPacketType:Bool {
            get {
                return builderResult.hasPacketType
            }
        }
        @discardableResult
        public func setPacketType(_ value:String) -> KpAlive.Builder {
            self.packetType = value
            return self
        }
        @discardableResult
        public func clearPacketType() -> KpAlive.Builder{
            builderResult.hasPacketType = false
            builderResult.packetType = nil
            return self
        }
        ///sensor ID
        public var sensorId:String {
            get {
                return builderResult.sensorId
            }
            set (value) {
                builderResult.hasSensorId = true
                builderResult.sensorId = value
            }
        }
        public var hasSensorId:Bool {
            get {
                return builderResult.hasSensorId
            }
        }
        @discardableResult
        public func setSensorId(_ value:String) -> KpAlive.Builder {
            self.sensorId = value
            return self
        }
        @discardableResult
        public func clearSensorId() -> KpAlive.Builder{
            builderResult.hasSensorId = false
            builderResult.sensorId = nil
            return self
        }
        public var aliveFlag:UInt32 {
            get {
                return builderResult.aliveFlag
            }
            set (value) {
                builderResult.hasAliveFlag = true
                builderResult.aliveFlag = value
            }
        }
        public var hasAliveFlag:Bool {
            get {
                return builderResult.hasAliveFlag
            }
        }
        @discardableResult
        public func setAliveFlag(_ value:UInt32) -> KpAlive.Builder {
            self.aliveFlag = value
            return self
        }
        @discardableResult
        public func clearAliveFlag() -> KpAlive.Builder{
            builderResult.hasAliveFlag = false
            builderResult.aliveFlag = nil
            return self
        }
        public var countryCode:String {
            get {
                return builderResult.countryCode
            }
            set (value) {
                builderResult.hasCountryCode = true
                builderResult.countryCode = value
            }
        }
        public var hasCountryCode:Bool {
            get {
                return builderResult.hasCountryCode
            }
        }
        @discardableResult
        public func setCountryCode(_ value:String) -> KpAlive.Builder {
            self.countryCode = value
            return self
        }
        @discardableResult
        public func clearCountryCode() -> KpAlive.Builder{
            builderResult.hasCountryCode = false
            builderResult.countryCode = nil
            return self
        }
        public var cityCode:String {
            get {
                return builderResult.cityCode
            }
            set (value) {
                builderResult.hasCityCode = true
                builderResult.cityCode = value
            }
        }
        public var hasCityCode:Bool {
            get {
                return builderResult.hasCityCode
            }
        }
        @discardableResult
        public func setCityCode(_ value:String) -> KpAlive.Builder {
            self.cityCode = value
            return self
        }
        @discardableResult
        public func clearCityCode() -> KpAlive.Builder{
            builderResult.hasCityCode = false
            builderResult.cityCode = nil
            return self
        }
        public var version:String {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:String) -> KpAlive.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> KpAlive.Builder{
            builderResult.hasVersion = false
            builderResult.version = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> KpAlive.Builder {
            builderResult = KpAlive()
            return self
        }
        override public func clone() throws -> KpAlive.Builder {
            return try KpAlive.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> KpAlive {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> KpAlive {
            let returnMe:KpAlive = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:KpAlive) throws -> KpAlive.Builder {
            if other == KpAlive() {
                return self
            }
            if other.hasPacketType {
                packetType = other.packetType
            }
            if other.hasSensorId {
                sensorId = other.sensorId
            }
            if other.hasAliveFlag {
                aliveFlag = other.aliveFlag
            }
            if other.hasCountryCode {
                countryCode = other.countryCode
            }
            if other.hasCityCode {
                cityCode = other.cityCode
            }
            if other.hasVersion {
                version = other.version
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> KpAlive.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> KpAlive.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    packetType = try codedInputStream.readString()

                case 18:
                    sensorId = try codedInputStream.readString()

                case 24:
                    aliveFlag = try codedInputStream.readUInt32()

                case 34:
                    countryCode = try codedInputStream.readString()

                case 42:
                    cityCode = try codedInputStream.readString()

                case 50:
                    version = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> KpAlive.Builder {
            let resultDecodedBuilder = KpAlive.Builder()
            if let jsonValuePacketType = jsonMap["packetType"] as? String {
                resultDecodedBuilder.packetType = jsonValuePacketType
            }
            if let jsonValueSensorId = jsonMap["sensorID"] as? String {
                resultDecodedBuilder.sensorId = jsonValueSensorId
            }
            if let jsonValueAliveFlag = jsonMap["aliveFlag"] as? UInt {
                resultDecodedBuilder.aliveFlag = UInt32(jsonValueAliveFlag)
            } else if let jsonValueAliveFlag = jsonMap["aliveFlag"] as? String {
                resultDecodedBuilder.aliveFlag = UInt32(jsonValueAliveFlag)!
            }
            if let jsonValueCountryCode = jsonMap["countryCode"] as? String {
                resultDecodedBuilder.countryCode = jsonValueCountryCode
            }
            if let jsonValueCityCode = jsonMap["cityCode"] as? String {
                resultDecodedBuilder.cityCode = jsonValueCityCode
            }
            if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = jsonValueVersion
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> KpAlive.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try KpAlive.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class EqEvent : GeneratedMessage {
    public typealias BuilderType = EqEvent.Builder

    public static func == (lhs: EqEvent, rhs: EqEvent) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasPacketType == rhs.hasPacketType) && (!lhs.hasPacketType || lhs.packetType == rhs.packetType)
        fieldCheck = fieldCheck && (lhs.hasSensorId == rhs.hasSensorId) && (!lhs.hasSensorId || lhs.sensorId == rhs.sensorId)
        fieldCheck = fieldCheck && (lhs.hasEventOutput == rhs.hasEventOutput) && (!lhs.hasEventOutput || lhs.eventOutput == rhs.eventOutput)
        fieldCheck = fieldCheck && (lhs.hasEventSec == rhs.hasEventSec) && (!lhs.hasEventSec || lhs.eventSec == rhs.eventSec)
        fieldCheck = fieldCheck && (lhs.hasEventUsec == rhs.hasEventUsec) && (!lhs.hasEventUsec || lhs.eventUsec == rhs.eventUsec)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    ///earthquake event packet : 1
    public fileprivate(set) var packetType:String! = nil
    public fileprivate(set) var hasPacketType:Bool = false

    ///sensor ID
    public fileprivate(set) var sensorId:String! = nil
    public fileprivate(set) var hasSensorId:Bool = false

    public fileprivate(set) var eventOutput:UInt32! = nil
    public fileprivate(set) var hasEventOutput:Bool = false

    public fileprivate(set) var eventSec:Int64! = nil
    public fileprivate(set) var hasEventSec:Bool = false

    public fileprivate(set) var eventUsec:Int64! = nil
    public fileprivate(set) var hasEventUsec:Bool = false

    public fileprivate(set) var version:String! = nil
    public fileprivate(set) var hasVersion:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasPacketType {
            try codedOutputStream.writeString(fieldNumber: 1, value:packetType)
        }
        if hasSensorId {
            try codedOutputStream.writeString(fieldNumber: 2, value:sensorId)
        }
        if hasEventOutput {
            try codedOutputStream.writeUInt32(fieldNumber: 3, value:eventOutput)
        }
        if hasEventSec {
            try codedOutputStream.writeInt64(fieldNumber: 4, value:eventSec)
        }
        if hasEventUsec {
            try codedOutputStream.writeInt64(fieldNumber: 5, value:eventUsec)
        }
        if hasVersion {
            try codedOutputStream.writeString(fieldNumber: 6, value:version)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPacketType {
            serialize_size += packetType.computeStringSize(fieldNumber: 1)
        }
        if hasSensorId {
            serialize_size += sensorId.computeStringSize(fieldNumber: 2)
        }
        if hasEventOutput {
            serialize_size += eventOutput.computeUInt32Size(fieldNumber: 3)
        }
        if hasEventSec {
            serialize_size += eventSec.computeInt64Size(fieldNumber: 4)
        }
        if hasEventUsec {
            serialize_size += eventUsec.computeInt64Size(fieldNumber: 5)
        }
        if hasVersion {
            serialize_size += version.computeStringSize(fieldNumber: 6)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> EqEvent.Builder {
        return EqEvent.classBuilder() as! EqEvent.Builder
    }
    public func getBuilder() -> EqEvent.Builder {
        return classBuilder() as! EqEvent.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return EqEvent.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return EqEvent.Builder()
    }
    public func toBuilder() throws -> EqEvent.Builder {
        return try EqEvent.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:EqEvent) throws -> EqEvent.Builder {
        return try EqEvent.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasPacketType {
            jsonMap["packetType"] = packetType
        }
        if hasSensorId {
            jsonMap["sensorID"] = sensorId
        }
        if hasEventOutput {
            jsonMap["eventOutput"] = UInt(eventOutput)
        }
        if hasEventSec {
            jsonMap["eventSec"] = "\(eventSec!)"
        }
        if hasEventUsec {
            jsonMap["eventUsec"] = "\(eventUsec!)"
        }
        if hasVersion {
            jsonMap["version"] = version
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> EqEvent {
        return try EqEvent.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> EqEvent {
        return try EqEvent.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasPacketType {
            output += "\(indent) packetType: \(String(describing: packetType)) \n"
        }
        if hasSensorId {
            output += "\(indent) sensorId: \(String(describing: sensorId)) \n"
        }
        if hasEventOutput {
            output += "\(indent) eventOutput: \(String(describing: eventOutput)) \n"
        }
        if hasEventSec {
            output += "\(indent) eventSec: \(String(describing: eventSec)) \n"
        }
        if hasEventUsec {
            output += "\(indent) eventUsec: \(String(describing: eventUsec)) \n"
        }
        if hasVersion {
            output += "\(indent) version: \(String(describing: version)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasPacketType {
                hashCode = (hashCode &* 31) &+ packetType.hashValue
            }
            if hasSensorId {
                hashCode = (hashCode &* 31) &+ sensorId.hashValue
            }
            if hasEventOutput {
                hashCode = (hashCode &* 31) &+ eventOutput.hashValue
            }
            if hasEventSec {
                hashCode = (hashCode &* 31) &+ eventSec.hashValue
            }
            if hasEventUsec {
                hashCode = (hashCode &* 31) &+ eventUsec.hashValue
            }
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "EqEvent"
    }
    override public func className() -> String {
        return "EqEvent"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:EqEvent = EqEvent()
        public func getMessage() -> EqEvent {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        ///earthquake event packet : 1
        public var packetType:String {
            get {
                return builderResult.packetType
            }
            set (value) {
                builderResult.hasPacketType = true
                builderResult.packetType = value
            }
        }
        public var hasPacketType:Bool {
            get {
                return builderResult.hasPacketType
            }
        }
        @discardableResult
        public func setPacketType(_ value:String) -> EqEvent.Builder {
            self.packetType = value
            return self
        }
        @discardableResult
        public func clearPacketType() -> EqEvent.Builder{
            builderResult.hasPacketType = false
            builderResult.packetType = nil
            return self
        }
        ///sensor ID
        public var sensorId:String {
            get {
                return builderResult.sensorId
            }
            set (value) {
                builderResult.hasSensorId = true
                builderResult.sensorId = value
            }
        }
        public var hasSensorId:Bool {
            get {
                return builderResult.hasSensorId
            }
        }
        @discardableResult
        public func setSensorId(_ value:String) -> EqEvent.Builder {
            self.sensorId = value
            return self
        }
        @discardableResult
        public func clearSensorId() -> EqEvent.Builder{
            builderResult.hasSensorId = false
            builderResult.sensorId = nil
            return self
        }
        public var eventOutput:UInt32 {
            get {
                return builderResult.eventOutput
            }
            set (value) {
                builderResult.hasEventOutput = true
                builderResult.eventOutput = value
            }
        }
        public var hasEventOutput:Bool {
            get {
                return builderResult.hasEventOutput
            }
        }
        @discardableResult
        public func setEventOutput(_ value:UInt32) -> EqEvent.Builder {
            self.eventOutput = value
            return self
        }
        @discardableResult
        public func clearEventOutput() -> EqEvent.Builder{
            builderResult.hasEventOutput = false
            builderResult.eventOutput = nil
            return self
        }
        public var eventSec:Int64 {
            get {
                return builderResult.eventSec
            }
            set (value) {
                builderResult.hasEventSec = true
                builderResult.eventSec = value
            }
        }
        public var hasEventSec:Bool {
            get {
                return builderResult.hasEventSec
            }
        }
        @discardableResult
        public func setEventSec(_ value:Int64) -> EqEvent.Builder {
            self.eventSec = value
            return self
        }
        @discardableResult
        public func clearEventSec() -> EqEvent.Builder{
            builderResult.hasEventSec = false
            builderResult.eventSec = nil
            return self
        }
        public var eventUsec:Int64 {
            get {
                return builderResult.eventUsec
            }
            set (value) {
                builderResult.hasEventUsec = true
                builderResult.eventUsec = value
            }
        }
        public var hasEventUsec:Bool {
            get {
                return builderResult.hasEventUsec
            }
        }
        @discardableResult
        public func setEventUsec(_ value:Int64) -> EqEvent.Builder {
            self.eventUsec = value
            return self
        }
        @discardableResult
        public func clearEventUsec() -> EqEvent.Builder{
            builderResult.hasEventUsec = false
            builderResult.eventUsec = nil
            return self
        }
        public var version:String {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:String) -> EqEvent.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> EqEvent.Builder{
            builderResult.hasVersion = false
            builderResult.version = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> EqEvent.Builder {
            builderResult = EqEvent()
            return self
        }
        override public func clone() throws -> EqEvent.Builder {
            return try EqEvent.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> EqEvent {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> EqEvent {
            let returnMe:EqEvent = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:EqEvent) throws -> EqEvent.Builder {
            if other == EqEvent() {
                return self
            }
            if other.hasPacketType {
                packetType = other.packetType
            }
            if other.hasSensorId {
                sensorId = other.sensorId
            }
            if other.hasEventOutput {
                eventOutput = other.eventOutput
            }
            if other.hasEventSec {
                eventSec = other.eventSec
            }
            if other.hasEventUsec {
                eventUsec = other.eventUsec
            }
            if other.hasVersion {
                version = other.version
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> EqEvent.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EqEvent.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    packetType = try codedInputStream.readString()

                case 18:
                    sensorId = try codedInputStream.readString()

                case 24:
                    eventOutput = try codedInputStream.readUInt32()

                case 32:
                    eventSec = try codedInputStream.readInt64()

                case 40:
                    eventUsec = try codedInputStream.readInt64()

                case 50:
                    version = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> EqEvent.Builder {
            let resultDecodedBuilder = EqEvent.Builder()
            if let jsonValuePacketType = jsonMap["packetType"] as? String {
                resultDecodedBuilder.packetType = jsonValuePacketType
            }
            if let jsonValueSensorId = jsonMap["sensorID"] as? String {
                resultDecodedBuilder.sensorId = jsonValueSensorId
            }
            if let jsonValueEventOutput = jsonMap["eventOutput"] as? UInt {
                resultDecodedBuilder.eventOutput = UInt32(jsonValueEventOutput)
            } else if let jsonValueEventOutput = jsonMap["eventOutput"] as? String {
                resultDecodedBuilder.eventOutput = UInt32(jsonValueEventOutput)!
            }
            if let jsonValueEventSec = jsonMap["eventSec"] as? String {
                resultDecodedBuilder.eventSec = Int64(jsonValueEventSec)!
            } else if let jsonValueEventSec = jsonMap["eventSec"] as? Int {
                resultDecodedBuilder.eventSec = Int64(jsonValueEventSec)
            }
            if let jsonValueEventUsec = jsonMap["eventUsec"] as? String {
                resultDecodedBuilder.eventUsec = Int64(jsonValueEventUsec)!
            } else if let jsonValueEventUsec = jsonMap["eventUsec"] as? Int {
                resultDecodedBuilder.eventUsec = Int64(jsonValueEventUsec)
            }
            if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = jsonValueVersion
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> EqEvent.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try EqEvent.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class EqOccur : GeneratedMessage {
    public typealias BuilderType = EqOccur.Builder

    public static func == (lhs: EqOccur, rhs: EqOccur) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasPacketType == rhs.hasPacketType) && (!lhs.hasPacketType || lhs.packetType == rhs.packetType)
        fieldCheck = fieldCheck && (lhs.hasInformation == rhs.hasInformation) && (!lhs.hasInformation || lhs.information == rhs.information)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    ///earthquake occur packet : 2
    public fileprivate(set) var packetType:String! = nil
    public fileprivate(set) var hasPacketType:Bool = false

    public fileprivate(set) var information:String! = nil
    public fileprivate(set) var hasInformation:Bool = false

    public fileprivate(set) var version:String! = nil
    public fileprivate(set) var hasVersion:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasPacketType {
            try codedOutputStream.writeString(fieldNumber: 1, value:packetType)
        }
        if hasInformation {
            try codedOutputStream.writeString(fieldNumber: 2, value:information)
        }
        if hasVersion {
            try codedOutputStream.writeString(fieldNumber: 3, value:version)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPacketType {
            serialize_size += packetType.computeStringSize(fieldNumber: 1)
        }
        if hasInformation {
            serialize_size += information.computeStringSize(fieldNumber: 2)
        }
        if hasVersion {
            serialize_size += version.computeStringSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> EqOccur.Builder {
        return EqOccur.classBuilder() as! EqOccur.Builder
    }
    public func getBuilder() -> EqOccur.Builder {
        return classBuilder() as! EqOccur.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return EqOccur.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return EqOccur.Builder()
    }
    public func toBuilder() throws -> EqOccur.Builder {
        return try EqOccur.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:EqOccur) throws -> EqOccur.Builder {
        return try EqOccur.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasPacketType {
            jsonMap["packetType"] = packetType
        }
        if hasInformation {
            jsonMap["information"] = information
        }
        if hasVersion {
            jsonMap["version"] = version
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> EqOccur {
        return try EqOccur.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> EqOccur {
        return try EqOccur.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasPacketType {
            output += "\(indent) packetType: \(String(describing: packetType)) \n"
        }
        if hasInformation {
            output += "\(indent) information: \(String(describing: information)) \n"
        }
        if hasVersion {
            output += "\(indent) version: \(String(describing: version)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasPacketType {
                hashCode = (hashCode &* 31) &+ packetType.hashValue
            }
            if hasInformation {
                hashCode = (hashCode &* 31) &+ information.hashValue
            }
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "EqOccur"
    }
    override public func className() -> String {
        return "EqOccur"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:EqOccur = EqOccur()
        public func getMessage() -> EqOccur {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        ///earthquake occur packet : 2
        public var packetType:String {
            get {
                return builderResult.packetType
            }
            set (value) {
                builderResult.hasPacketType = true
                builderResult.packetType = value
            }
        }
        public var hasPacketType:Bool {
            get {
                return builderResult.hasPacketType
            }
        }
        @discardableResult
        public func setPacketType(_ value:String) -> EqOccur.Builder {
            self.packetType = value
            return self
        }
        @discardableResult
        public func clearPacketType() -> EqOccur.Builder{
            builderResult.hasPacketType = false
            builderResult.packetType = nil
            return self
        }
        public var information:String {
            get {
                return builderResult.information
            }
            set (value) {
                builderResult.hasInformation = true
                builderResult.information = value
            }
        }
        public var hasInformation:Bool {
            get {
                return builderResult.hasInformation
            }
        }
        @discardableResult
        public func setInformation(_ value:String) -> EqOccur.Builder {
            self.information = value
            return self
        }
        @discardableResult
        public func clearInformation() -> EqOccur.Builder{
            builderResult.hasInformation = false
            builderResult.information = nil
            return self
        }
        public var version:String {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:String) -> EqOccur.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> EqOccur.Builder{
            builderResult.hasVersion = false
            builderResult.version = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> EqOccur.Builder {
            builderResult = EqOccur()
            return self
        }
        override public func clone() throws -> EqOccur.Builder {
            return try EqOccur.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> EqOccur {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> EqOccur {
            let returnMe:EqOccur = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:EqOccur) throws -> EqOccur.Builder {
            if other == EqOccur() {
                return self
            }
            if other.hasPacketType {
                packetType = other.packetType
            }
            if other.hasInformation {
                information = other.information
            }
            if other.hasVersion {
                version = other.version
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> EqOccur.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EqOccur.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    packetType = try codedInputStream.readString()

                case 18:
                    information = try codedInputStream.readString()

                case 26:
                    version = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> EqOccur.Builder {
            let resultDecodedBuilder = EqOccur.Builder()
            if let jsonValuePacketType = jsonMap["packetType"] as? String {
                resultDecodedBuilder.packetType = jsonValuePacketType
            }
            if let jsonValueInformation = jsonMap["information"] as? String {
                resultDecodedBuilder.information = jsonValueInformation
            }
            if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = jsonValueVersion
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> EqOccur.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try EqOccur.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class BootAsk : GeneratedMessage {
    public typealias BuilderType = BootAsk.Builder

    public static func == (lhs: BootAsk, rhs: BootAsk) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasPacketType == rhs.hasPacketType) && (!lhs.hasPacketType || lhs.packetType == rhs.packetType)
        fieldCheck = fieldCheck && (lhs.hasServerIp == rhs.hasServerIp) && (!lhs.hasServerIp || lhs.serverIp == rhs.serverIp)
        fieldCheck = fieldCheck && (lhs.hasServerPort == rhs.hasServerPort) && (!lhs.hasServerPort || lhs.serverPort == rhs.serverPort)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    ///earthquake occur packet : 3
    public fileprivate(set) var packetType:String! = nil
    public fileprivate(set) var hasPacketType:Bool = false

    ///server IP
    public fileprivate(set) var serverIp:String! = nil
    public fileprivate(set) var hasServerIp:Bool = false

    public fileprivate(set) var serverPort:Int32! = nil
    public fileprivate(set) var hasServerPort:Bool = false

    public fileprivate(set) var version:String! = nil
    public fileprivate(set) var hasVersion:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasPacketType {
            try codedOutputStream.writeString(fieldNumber: 1, value:packetType)
        }
        if hasServerIp {
            try codedOutputStream.writeString(fieldNumber: 2, value:serverIp)
        }
        if hasServerPort {
            try codedOutputStream.writeInt32(fieldNumber: 3, value:serverPort)
        }
        if hasVersion {
            try codedOutputStream.writeString(fieldNumber: 4, value:version)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPacketType {
            serialize_size += packetType.computeStringSize(fieldNumber: 1)
        }
        if hasServerIp {
            serialize_size += serverIp.computeStringSize(fieldNumber: 2)
        }
        if hasServerPort {
            serialize_size += serverPort.computeInt32Size(fieldNumber: 3)
        }
        if hasVersion {
            serialize_size += version.computeStringSize(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> BootAsk.Builder {
        return BootAsk.classBuilder() as! BootAsk.Builder
    }
    public func getBuilder() -> BootAsk.Builder {
        return classBuilder() as! BootAsk.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return BootAsk.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return BootAsk.Builder()
    }
    public func toBuilder() throws -> BootAsk.Builder {
        return try BootAsk.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:BootAsk) throws -> BootAsk.Builder {
        return try BootAsk.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasPacketType {
            jsonMap["packetType"] = packetType
        }
        if hasServerIp {
            jsonMap["serverIP"] = serverIp
        }
        if hasServerPort {
            jsonMap["serverPort"] = Int(serverPort)
        }
        if hasVersion {
            jsonMap["version"] = version
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> BootAsk {
        return try BootAsk.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> BootAsk {
        return try BootAsk.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasPacketType {
            output += "\(indent) packetType: \(String(describing: packetType)) \n"
        }
        if hasServerIp {
            output += "\(indent) serverIp: \(String(describing: serverIp)) \n"
        }
        if hasServerPort {
            output += "\(indent) serverPort: \(String(describing: serverPort)) \n"
        }
        if hasVersion {
            output += "\(indent) version: \(String(describing: version)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasPacketType {
                hashCode = (hashCode &* 31) &+ packetType.hashValue
            }
            if hasServerIp {
                hashCode = (hashCode &* 31) &+ serverIp.hashValue
            }
            if hasServerPort {
                hashCode = (hashCode &* 31) &+ serverPort.hashValue
            }
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "BootAsk"
    }
    override public func className() -> String {
        return "BootAsk"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:BootAsk = BootAsk()
        public func getMessage() -> BootAsk {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        ///earthquake occur packet : 3
        public var packetType:String {
            get {
                return builderResult.packetType
            }
            set (value) {
                builderResult.hasPacketType = true
                builderResult.packetType = value
            }
        }
        public var hasPacketType:Bool {
            get {
                return builderResult.hasPacketType
            }
        }
        @discardableResult
        public func setPacketType(_ value:String) -> BootAsk.Builder {
            self.packetType = value
            return self
        }
        @discardableResult
        public func clearPacketType() -> BootAsk.Builder{
            builderResult.hasPacketType = false
            builderResult.packetType = nil
            return self
        }
        ///server IP
        public var serverIp:String {
            get {
                return builderResult.serverIp
            }
            set (value) {
                builderResult.hasServerIp = true
                builderResult.serverIp = value
            }
        }
        public var hasServerIp:Bool {
            get {
                return builderResult.hasServerIp
            }
        }
        @discardableResult
        public func setServerIp(_ value:String) -> BootAsk.Builder {
            self.serverIp = value
            return self
        }
        @discardableResult
        public func clearServerIp() -> BootAsk.Builder{
            builderResult.hasServerIp = false
            builderResult.serverIp = nil
            return self
        }
        public var serverPort:Int32 {
            get {
                return builderResult.serverPort
            }
            set (value) {
                builderResult.hasServerPort = true
                builderResult.serverPort = value
            }
        }
        public var hasServerPort:Bool {
            get {
                return builderResult.hasServerPort
            }
        }
        @discardableResult
        public func setServerPort(_ value:Int32) -> BootAsk.Builder {
            self.serverPort = value
            return self
        }
        @discardableResult
        public func clearServerPort() -> BootAsk.Builder{
            builderResult.hasServerPort = false
            builderResult.serverPort = nil
            return self
        }
        public var version:String {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:String) -> BootAsk.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> BootAsk.Builder{
            builderResult.hasVersion = false
            builderResult.version = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> BootAsk.Builder {
            builderResult = BootAsk()
            return self
        }
        override public func clone() throws -> BootAsk.Builder {
            return try BootAsk.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> BootAsk {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> BootAsk {
            let returnMe:BootAsk = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:BootAsk) throws -> BootAsk.Builder {
            if other == BootAsk() {
                return self
            }
            if other.hasPacketType {
                packetType = other.packetType
            }
            if other.hasServerIp {
                serverIp = other.serverIp
            }
            if other.hasServerPort {
                serverPort = other.serverPort
            }
            if other.hasVersion {
                version = other.version
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> BootAsk.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BootAsk.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    packetType = try codedInputStream.readString()

                case 18:
                    serverIp = try codedInputStream.readString()

                case 24:
                    serverPort = try codedInputStream.readInt32()

                case 34:
                    version = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> BootAsk.Builder {
            let resultDecodedBuilder = BootAsk.Builder()
            if let jsonValuePacketType = jsonMap["packetType"] as? String {
                resultDecodedBuilder.packetType = jsonValuePacketType
            }
            if let jsonValueServerIp = jsonMap["serverIP"] as? String {
                resultDecodedBuilder.serverIp = jsonValueServerIp
            }
            if let jsonValueServerPort = jsonMap["serverPort"] as? Int {
                resultDecodedBuilder.serverPort = Int32(jsonValueServerPort)
            } else if let jsonValueServerPort = jsonMap["serverPort"] as? String {
                resultDecodedBuilder.serverPort = Int32(jsonValueServerPort)!
            }
            if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = jsonValueVersion
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> BootAsk.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try BootAsk.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class BootKp : GeneratedMessage {
    public typealias BuilderType = BootKp.Builder

    public static func == (lhs: BootKp, rhs: BootKp) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasPacketType == rhs.hasPacketType) && (!lhs.hasPacketType || lhs.packetType == rhs.packetType)
        fieldCheck = fieldCheck && (lhs.hasServerId == rhs.hasServerId) && (!lhs.hasServerId || lhs.serverId == rhs.serverId)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    ///earthquake occur packet : 4
    public fileprivate(set) var packetType:String! = nil
    public fileprivate(set) var hasPacketType:Bool = false

    public fileprivate(set) var serverId:String! = nil
    public fileprivate(set) var hasServerId:Bool = false

    public fileprivate(set) var version:String! = nil
    public fileprivate(set) var hasVersion:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasPacketType {
            try codedOutputStream.writeString(fieldNumber: 1, value:packetType)
        }
        if hasServerId {
            try codedOutputStream.writeString(fieldNumber: 2, value:serverId)
        }
        if hasVersion {
            try codedOutputStream.writeString(fieldNumber: 3, value:version)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPacketType {
            serialize_size += packetType.computeStringSize(fieldNumber: 1)
        }
        if hasServerId {
            serialize_size += serverId.computeStringSize(fieldNumber: 2)
        }
        if hasVersion {
            serialize_size += version.computeStringSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> BootKp.Builder {
        return BootKp.classBuilder() as! BootKp.Builder
    }
    public func getBuilder() -> BootKp.Builder {
        return classBuilder() as! BootKp.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return BootKp.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return BootKp.Builder()
    }
    public func toBuilder() throws -> BootKp.Builder {
        return try BootKp.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:BootKp) throws -> BootKp.Builder {
        return try BootKp.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasPacketType {
            jsonMap["packetType"] = packetType
        }
        if hasServerId {
            jsonMap["serverID"] = serverId
        }
        if hasVersion {
            jsonMap["version"] = version
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> BootKp {
        return try BootKp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> BootKp {
        return try BootKp.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasPacketType {
            output += "\(indent) packetType: \(String(describing: packetType)) \n"
        }
        if hasServerId {
            output += "\(indent) serverId: \(String(describing: serverId)) \n"
        }
        if hasVersion {
            output += "\(indent) version: \(String(describing: version)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasPacketType {
                hashCode = (hashCode &* 31) &+ packetType.hashValue
            }
            if hasServerId {
                hashCode = (hashCode &* 31) &+ serverId.hashValue
            }
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "BootKp"
    }
    override public func className() -> String {
        return "BootKp"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:BootKp = BootKp()
        public func getMessage() -> BootKp {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        ///earthquake occur packet : 4
        public var packetType:String {
            get {
                return builderResult.packetType
            }
            set (value) {
                builderResult.hasPacketType = true
                builderResult.packetType = value
            }
        }
        public var hasPacketType:Bool {
            get {
                return builderResult.hasPacketType
            }
        }
        @discardableResult
        public func setPacketType(_ value:String) -> BootKp.Builder {
            self.packetType = value
            return self
        }
        @discardableResult
        public func clearPacketType() -> BootKp.Builder{
            builderResult.hasPacketType = false
            builderResult.packetType = nil
            return self
        }
        public var serverId:String {
            get {
                return builderResult.serverId
            }
            set (value) {
                builderResult.hasServerId = true
                builderResult.serverId = value
            }
        }
        public var hasServerId:Bool {
            get {
                return builderResult.hasServerId
            }
        }
        @discardableResult
        public func setServerId(_ value:String) -> BootKp.Builder {
            self.serverId = value
            return self
        }
        @discardableResult
        public func clearServerId() -> BootKp.Builder{
            builderResult.hasServerId = false
            builderResult.serverId = nil
            return self
        }
        public var version:String {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:String) -> BootKp.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> BootKp.Builder{
            builderResult.hasVersion = false
            builderResult.version = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> BootKp.Builder {
            builderResult = BootKp()
            return self
        }
        override public func clone() throws -> BootKp.Builder {
            return try BootKp.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> BootKp {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> BootKp {
            let returnMe:BootKp = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:BootKp) throws -> BootKp.Builder {
            if other == BootKp() {
                return self
            }
            if other.hasPacketType {
                packetType = other.packetType
            }
            if other.hasServerId {
                serverId = other.serverId
            }
            if other.hasVersion {
                version = other.version
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> BootKp.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BootKp.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    packetType = try codedInputStream.readString()

                case 18:
                    serverId = try codedInputStream.readString()

                case 26:
                    version = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> BootKp.Builder {
            let resultDecodedBuilder = BootKp.Builder()
            if let jsonValuePacketType = jsonMap["packetType"] as? String {
                resultDecodedBuilder.packetType = jsonValuePacketType
            }
            if let jsonValueServerId = jsonMap["serverID"] as? String {
                resultDecodedBuilder.serverId = jsonValueServerId
            }
            if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = jsonValueVersion
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> BootKp.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try BootKp.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class KpAliveAck : GeneratedMessage {
    public typealias BuilderType = KpAliveAck.Builder

    public static func == (lhs: KpAliveAck, rhs: KpAliveAck) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasPacketType == rhs.hasPacketType) && (!lhs.hasPacketType || lhs.packetType == rhs.packetType)
        fieldCheck = fieldCheck && (lhs.hasRole == rhs.hasRole) && (!lhs.hasRole || lhs.role == rhs.role)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    ///user keep alive with ack respond : 5
    public fileprivate(set) var packetType:String! = nil
    public fileprivate(set) var hasPacketType:Bool = false

    /// server : 1 ; user : 0
    public fileprivate(set) var role:String! = nil
    public fileprivate(set) var hasRole:Bool = false

    public fileprivate(set) var version:String! = nil
    public fileprivate(set) var hasVersion:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasPacketType {
            try codedOutputStream.writeString(fieldNumber: 1, value:packetType)
        }
        if hasRole {
            try codedOutputStream.writeString(fieldNumber: 2, value:role)
        }
        if hasVersion {
            try codedOutputStream.writeString(fieldNumber: 3, value:version)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPacketType {
            serialize_size += packetType.computeStringSize(fieldNumber: 1)
        }
        if hasRole {
            serialize_size += role.computeStringSize(fieldNumber: 2)
        }
        if hasVersion {
            serialize_size += version.computeStringSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> KpAliveAck.Builder {
        return KpAliveAck.classBuilder() as! KpAliveAck.Builder
    }
    public func getBuilder() -> KpAliveAck.Builder {
        return classBuilder() as! KpAliveAck.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return KpAliveAck.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return KpAliveAck.Builder()
    }
    public func toBuilder() throws -> KpAliveAck.Builder {
        return try KpAliveAck.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:KpAliveAck) throws -> KpAliveAck.Builder {
        return try KpAliveAck.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasPacketType {
            jsonMap["packetType"] = packetType
        }
        if hasRole {
            jsonMap["role"] = role
        }
        if hasVersion {
            jsonMap["version"] = version
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> KpAliveAck {
        return try KpAliveAck.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> KpAliveAck {
        return try KpAliveAck.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasPacketType {
            output += "\(indent) packetType: \(String(describing: packetType)) \n"
        }
        if hasRole {
            output += "\(indent) role: \(String(describing: role)) \n"
        }
        if hasVersion {
            output += "\(indent) version: \(String(describing: version)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasPacketType {
                hashCode = (hashCode &* 31) &+ packetType.hashValue
            }
            if hasRole {
                hashCode = (hashCode &* 31) &+ role.hashValue
            }
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "KpAliveAck"
    }
    override public func className() -> String {
        return "KpAliveAck"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:KpAliveAck = KpAliveAck()
        public func getMessage() -> KpAliveAck {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        ///user keep alive with ack respond : 5
        public var packetType:String {
            get {
                return builderResult.packetType
            }
            set (value) {
                builderResult.hasPacketType = true
                builderResult.packetType = value
            }
        }
        public var hasPacketType:Bool {
            get {
                return builderResult.hasPacketType
            }
        }
        @discardableResult
        public func setPacketType(_ value:String) -> KpAliveAck.Builder {
            self.packetType = value
            return self
        }
        @discardableResult
        public func clearPacketType() -> KpAliveAck.Builder{
            builderResult.hasPacketType = false
            builderResult.packetType = nil
            return self
        }
        /// server : 1 ; user : 0
        public var role:String {
            get {
                return builderResult.role
            }
            set (value) {
                builderResult.hasRole = true
                builderResult.role = value
            }
        }
        public var hasRole:Bool {
            get {
                return builderResult.hasRole
            }
        }
        @discardableResult
        public func setRole(_ value:String) -> KpAliveAck.Builder {
            self.role = value
            return self
        }
        @discardableResult
        public func clearRole() -> KpAliveAck.Builder{
            builderResult.hasRole = false
            builderResult.role = nil
            return self
        }
        public var version:String {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:String) -> KpAliveAck.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> KpAliveAck.Builder{
            builderResult.hasVersion = false
            builderResult.version = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> KpAliveAck.Builder {
            builderResult = KpAliveAck()
            return self
        }
        override public func clone() throws -> KpAliveAck.Builder {
            return try KpAliveAck.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> KpAliveAck {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> KpAliveAck {
            let returnMe:KpAliveAck = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:KpAliveAck) throws -> KpAliveAck.Builder {
            if other == KpAliveAck() {
                return self
            }
            if other.hasPacketType {
                packetType = other.packetType
            }
            if other.hasRole {
                role = other.role
            }
            if other.hasVersion {
                version = other.version
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> KpAliveAck.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> KpAliveAck.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    packetType = try codedInputStream.readString()

                case 18:
                    role = try codedInputStream.readString()

                case 26:
                    version = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> KpAliveAck.Builder {
            let resultDecodedBuilder = KpAliveAck.Builder()
            if let jsonValuePacketType = jsonMap["packetType"] as? String {
                resultDecodedBuilder.packetType = jsonValuePacketType
            }
            if let jsonValueRole = jsonMap["role"] as? String {
                resultDecodedBuilder.role = jsonValueRole
            }
            if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = jsonValueVersion
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> KpAliveAck.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try KpAliveAck.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class PacketType : GeneratedMessage {
    public typealias BuilderType = PacketType.Builder

    public static func == (lhs: PacketType, rhs: PacketType) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasPacketType == rhs.hasPacketType) && (!lhs.hasPacketType || lhs.packetType == rhs.packetType)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var packetType:String! = nil
    public fileprivate(set) var hasPacketType:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasPacketType {
            try codedOutputStream.writeString(fieldNumber: 1, value:packetType)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPacketType {
            serialize_size += packetType.computeStringSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> PacketType.Builder {
        return PacketType.classBuilder() as! PacketType.Builder
    }
    public func getBuilder() -> PacketType.Builder {
        return classBuilder() as! PacketType.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PacketType.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PacketType.Builder()
    }
    public func toBuilder() throws -> PacketType.Builder {
        return try PacketType.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:PacketType) throws -> PacketType.Builder {
        return try PacketType.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasPacketType {
            jsonMap["packetType"] = packetType
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> PacketType {
        return try PacketType.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PacketType {
        return try PacketType.Builder.fromJSONToBuilder(data:data, options:options).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasPacketType {
            output += "\(indent) packetType: \(String(describing: packetType)) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasPacketType {
                hashCode = (hashCode &* 31) &+ packetType.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "PacketType"
    }
    override public func className() -> String {
        return "PacketType"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PacketType = PacketType()
        public func getMessage() -> PacketType {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var packetType:String {
            get {
                return builderResult.packetType
            }
            set (value) {
                builderResult.hasPacketType = true
                builderResult.packetType = value
            }
        }
        public var hasPacketType:Bool {
            get {
                return builderResult.hasPacketType
            }
        }
        @discardableResult
        public func setPacketType(_ value:String) -> PacketType.Builder {
            self.packetType = value
            return self
        }
        @discardableResult
        public func clearPacketType() -> PacketType.Builder{
            builderResult.hasPacketType = false
            builderResult.packetType = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> PacketType.Builder {
            builderResult = PacketType()
            return self
        }
        override public func clone() throws -> PacketType.Builder {
            return try PacketType.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> PacketType {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> PacketType {
            let returnMe:PacketType = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:PacketType) throws -> PacketType.Builder {
            if other == PacketType() {
                return self
            }
            if other.hasPacketType {
                packetType = other.packetType
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PacketType.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PacketType.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    packetType = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PacketType.Builder {
            let resultDecodedBuilder = PacketType.Builder()
            if let jsonValuePacketType = jsonMap["packetType"] as? String {
                resultDecodedBuilder.packetType = jsonValuePacketType
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> PacketType.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PacketType.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension KpAlive: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<KpAlive> {
        var mergedArray = Array<KpAlive>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> KpAlive? {
        return try KpAlive.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> KpAlive {
        return try KpAlive.Builder().mergeFrom(data: data, extensionRegistry:InterfaceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> KpAlive {
        return try KpAlive.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> KpAlive {
        return try KpAlive.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> KpAlive {
        return try KpAlive.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> KpAlive {
        return try KpAlive.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> KpAlive {
        return try KpAlive.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "packetType": return self.packetType
        case "sensorId": return self.sensorId
        case "aliveFlag": return self.aliveFlag
        case "countryCode": return self.countryCode
        case "cityCode": return self.cityCode
        case "version": return self.version
        default: return nil
        }
    }
}
extension KpAlive.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = KpAlive
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "packetType": return self.packetType
            case "sensorId": return self.sensorId
            case "aliveFlag": return self.aliveFlag
            case "countryCode": return self.countryCode
            case "cityCode": return self.cityCode
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "packetType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.packetType = newSubscriptValue
            case "sensorId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sensorId = newSubscriptValue
            case "aliveFlag":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.aliveFlag = newSubscriptValue
            case "countryCode":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.countryCode = newSubscriptValue
            case "cityCode":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.cityCode = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension EqEvent: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<EqEvent> {
        var mergedArray = Array<EqEvent>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> EqEvent? {
        return try EqEvent.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> EqEvent {
        return try EqEvent.Builder().mergeFrom(data: data, extensionRegistry:InterfaceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> EqEvent {
        return try EqEvent.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> EqEvent {
        return try EqEvent.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> EqEvent {
        return try EqEvent.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> EqEvent {
        return try EqEvent.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EqEvent {
        return try EqEvent.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "packetType": return self.packetType
        case "sensorId": return self.sensorId
        case "eventOutput": return self.eventOutput
        case "eventSec": return self.eventSec
        case "eventUsec": return self.eventUsec
        case "version": return self.version
        default: return nil
        }
    }
}
extension EqEvent.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = EqEvent
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "packetType": return self.packetType
            case "sensorId": return self.sensorId
            case "eventOutput": return self.eventOutput
            case "eventSec": return self.eventSec
            case "eventUsec": return self.eventUsec
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "packetType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.packetType = newSubscriptValue
            case "sensorId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sensorId = newSubscriptValue
            case "eventOutput":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.eventOutput = newSubscriptValue
            case "eventSec":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.eventSec = newSubscriptValue
            case "eventUsec":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.eventUsec = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension EqOccur: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<EqOccur> {
        var mergedArray = Array<EqOccur>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> EqOccur? {
        return try EqOccur.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> EqOccur {
        return try EqOccur.Builder().mergeFrom(data: data, extensionRegistry:InterfaceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> EqOccur {
        return try EqOccur.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> EqOccur {
        return try EqOccur.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> EqOccur {
        return try EqOccur.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> EqOccur {
        return try EqOccur.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> EqOccur {
        return try EqOccur.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "packetType": return self.packetType
        case "information": return self.information
        case "version": return self.version
        default: return nil
        }
    }
}
extension EqOccur.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = EqOccur
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "packetType": return self.packetType
            case "information": return self.information
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "packetType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.packetType = newSubscriptValue
            case "information":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.information = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension BootAsk: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<BootAsk> {
        var mergedArray = Array<BootAsk>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> BootAsk? {
        return try BootAsk.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> BootAsk {
        return try BootAsk.Builder().mergeFrom(data: data, extensionRegistry:InterfaceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> BootAsk {
        return try BootAsk.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> BootAsk {
        return try BootAsk.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> BootAsk {
        return try BootAsk.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> BootAsk {
        return try BootAsk.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BootAsk {
        return try BootAsk.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "packetType": return self.packetType
        case "serverIp": return self.serverIp
        case "serverPort": return self.serverPort
        case "version": return self.version
        default: return nil
        }
    }
}
extension BootAsk.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = BootAsk
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "packetType": return self.packetType
            case "serverIp": return self.serverIp
            case "serverPort": return self.serverPort
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "packetType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.packetType = newSubscriptValue
            case "serverIp":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.serverIp = newSubscriptValue
            case "serverPort":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.serverPort = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension BootKp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<BootKp> {
        var mergedArray = Array<BootKp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> BootKp? {
        return try BootKp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> BootKp {
        return try BootKp.Builder().mergeFrom(data: data, extensionRegistry:InterfaceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> BootKp {
        return try BootKp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> BootKp {
        return try BootKp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> BootKp {
        return try BootKp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> BootKp {
        return try BootKp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BootKp {
        return try BootKp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "packetType": return self.packetType
        case "serverId": return self.serverId
        case "version": return self.version
        default: return nil
        }
    }
}
extension BootKp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = BootKp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "packetType": return self.packetType
            case "serverId": return self.serverId
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "packetType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.packetType = newSubscriptValue
            case "serverId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.serverId = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension KpAliveAck: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<KpAliveAck> {
        var mergedArray = Array<KpAliveAck>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> KpAliveAck? {
        return try KpAliveAck.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> KpAliveAck {
        return try KpAliveAck.Builder().mergeFrom(data: data, extensionRegistry:InterfaceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> KpAliveAck {
        return try KpAliveAck.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> KpAliveAck {
        return try KpAliveAck.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> KpAliveAck {
        return try KpAliveAck.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> KpAliveAck {
        return try KpAliveAck.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> KpAliveAck {
        return try KpAliveAck.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "packetType": return self.packetType
        case "role": return self.role
        case "version": return self.version
        default: return nil
        }
    }
}
extension KpAliveAck.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = KpAliveAck
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "packetType": return self.packetType
            case "role": return self.role
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "packetType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.packetType = newSubscriptValue
            case "role":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.role = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension PacketType: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PacketType> {
        var mergedArray = Array<PacketType>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> PacketType? {
        return try PacketType.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> PacketType {
        return try PacketType.Builder().mergeFrom(data: data, extensionRegistry:InterfaceRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PacketType {
        return try PacketType.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> PacketType {
        return try PacketType.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PacketType {
        return try PacketType.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> PacketType {
        return try PacketType.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PacketType {
        return try PacketType.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "packetType": return self.packetType
        default: return nil
        }
    }
}
extension PacketType.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = PacketType
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "packetType": return self.packetType
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "packetType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.packetType = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
